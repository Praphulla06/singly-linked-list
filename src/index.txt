use std::{cell::RefCell, rc::Rc};

#[derive(Debug)]
struct Node {
    data: i32,
    next: Option<Rc<RefCell<Node>>>,
}
impl Node {
    fn new(data: i32) -> Self {
        Self { data, next: None }
    }
}

#[derive(Debug)]
struct List {
    head: Option<Rc<RefCell<Node>>>,
    tail: Option<Rc<RefCell<Node>>>,
}
impl List {
    fn new() -> Self {
        Self {
            head: None,
            tail: None,
        }
    }
    fn is_empty(&mut self) -> bool {
        if self.head.is_none() && self.tail.is_none() {
            return true;
        }
        false
    }
    fn insert_at_head(&mut self, data: i32) {
        if self.is_empty() {
            let new_node = Rc::new(RefCell::new(Node::new(data)));
            self.head = Some(Rc::clone(&new_node));
            self.tail = Some(new_node);
        } else {
            let new_node = Rc::new(RefCell::new(Node::new(data)));
            new_node.borrow_mut().next = self.head.clone();
            self.head = Some(new_node);
        }
    }
    fn insert_at_tail(&mut self, data: i32) {
        if self.is_empty() {
            let new_node = Rc::new(RefCell::new(Node::new(data)));
            self.head = Some(Rc::clone(&new_node));
            self.tail = Some(new_node);
        } else {
            let new_node = Rc::new(RefCell::new(Node::new(data)));
            self.tail.as_ref().unwrap().borrow_mut().next = Some(Rc::clone(&new_node));
            self.tail = Some(new_node);
        }
    }
    fn delete_from_head(&mut self) {
        if self.is_empty() {
            println!("List is empty");
            return;
        } else {
            let old_head = self.head.take().unwrap();
            let next = old_head.borrow_mut().next.take();   
            self.head = next;

            if self.head.is_none() {
                self.tail = None;
            }
        }
    }
    fn delete_from_tail(&mut self) {
        if self.is_empty() {
            println!("The list is empty!");
            return;
        } else {
            // let mut current = Rc::clone(self.head.as_ref().unwrap());

            // while current.borrow().next.as_ref().unwrap().borrow().next.is_some() {
            //     let next = current.borrow().next.as_ref().unwrap();
            //     current = Rc::clone(next);
            // }            
        }
    }
}

fn main() {
    let mut l = List::new();
    l.insert_at_tail(100);
    l.insert_at_tail(400);
    l.insert_at_head(500);

    println!("{:#?}", l);
    l.delete_from_head();
    println!("{:#?}", l);
}
